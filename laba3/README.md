- 1. bool contains(int); поиск элемента в дереве по ключу
> Если нужное число меньше текущего, то идет влево
> Если больше – вправо
> Если равно выводит true
> Если не один из вариантов - выводит false
- 2. void insert(int); добавление элемента в дерево по ключу.
> если главного элемента нет, то создает новый элемент с новым числом
> если число уже есть, то выводит ошибку
> если число меньше текущего и если существует левый элемент текущего, то двигается влево, иначе добавляет новый элемент влево и увеличивается количество элементов
> если число больше текущего и если правый элемент текущего есть, то идет вправо, иначе добавляет новый элемент вправо и увеличивается количество элементов
> если количество элементов не увеличилось, то алгоритм повторяется
- 3. void remove(int); удаление элемента дерева по ключу
> Если числа в дереве нет, то выводит ошибку
> Если нужное число меньше текущего, то идет влево
> Если больше – вправо
> И так пока числа не станут равны
> Если не существует ни справа ни слева, то элемент – лист дерева
> И его программа просто удаляет
> Если нет лева, но есть право, то текущий идет в свой корень и перезаписывает указатели и удаляет выбранный элемент
> Если корня нет, то меняет указатели главного элемента и удаляет выбранный элемент
> Если нет право, но есть лево, то то текущий идет в свой корень и перезаписывает указатели и удаляет выбранный элемент
> Если корня нет, то меняет указатели главного элемента и удаляет выбранный элемент
> Если есть и право и лево, то идет вправо
> Если вправо есть лево, то двигаемся до конца в лево перезаписываем указатели и удаляем нужный элемент
- 4. Iterator create_dft_iterator(); создание итератора, реализующего один из
> методов обхода в глубину (depth-first traverse)
> Вставляет текущий элемент в список и идет влево и так пока лево есть
> Если есть право, то добавляет элемент и пропускает весь цикл
> Если право нет, то добавляет элемент
> Пока есть корень, то идет в него и выполняет ниже алгоритм
> Если есть право, и правого элемента нет в очереди, то идет вправо и пропускает весь цикл
> Если есть лево, и левого элемента нет в очереди, то идет влево и пропускает весь цикл
> Весь алгоритм выше выполняется, пока количество элементов очереди не станет равно количеству элементов дерева
> Сохраняет очередь и создает итератор
- 5. Iterator create_bft_iterator() создание итератора, реализующего методы
> обхода в ширину (breadth-first traverse)
> добавляет главный корень в очередь и идет в цикл от 0 до количества элементов дерева
> Если у левого элемента очереди есть лево, то добавляем в очередь левый элемент
> Если у левого элемента очереди есть право, то добавляем в очередь правый элемент
> Сохраняет очередь
